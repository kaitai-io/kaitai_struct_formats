meta:
  id: navec_pq_k_means
  title: navec product-quantized K-means file
  license: MIT
  -file-regex: ^pq\.bin$
  endian: le
  bit-endian: le

doc: |
  Files of navec word embedding library containing product-quantized k-means clusters. It is just a serialization format for data generated by `pqkmeans` library. The library by default recommends to use pickle. navec developers considered it as inacceptable and implemented an own serializer.
  It [has been proposed](https://github.com/natasha/navec/issues/3) to upstream it into vanilla `pqkmeans`, so the name of this spec can change in future.
  Sample files can be extracted from https://storage.yandexcloud.net/natasha-navec/packs/navec_news_v1_1B_250K_300d_100q.tar

doc-ref:
  - https://github.com/DwangoMediaVillage/pqkmeans
  - https://towardsdatascience.com/comprehensive-guide-to-approximate-nearest-neighbors-algorithms-8b94f057d6b6?gi=814ec3ce0d21
  - https://github.com/natasha/navec/blob/6584e40f896ba4e1aec55e25bd8f661637889c47/navec/pq.py#L70

seq:
  - id: header
    type: header
  - id: indexes
    -orig-id: indexes
    size: header.parts_count
    repeat: expr
    repeat-expr: header.vector_count
    doc: remapping of original vectors to their transformed representations. `indexes[original vector index]` is an array
  - id: code_words
    -orig-id:
      - codes # navec
      - codewords # pqkmeans
    type: quantised_vector
    repeat: expr
    repeat-expr: header.parts_count

types:
  quantised_vector:
    seq:
      - id: codes
        type: part
        repeat: expr
        repeat-expr: _root.header.centroid_count
    types:
      part:
        seq:
          - id: vec
            type: f4
            repeat: expr
            repeat-expr: _root.header.part_size
  header:
    -orig-id: meta
    seq:
      - id: vector_count
        -orig-id: vectors
        type: u4
      - id: original_vector_size
        -orig-id: dim
        type: u4
        doc: size of the original vectors
      - id: parts_count
        -orig-id:
          - qdim
          - num_subdim
        type: u4
        doc: when quantising, big vector is sliced into multiple vectors, then these subvectors are clustered separately. This variable gives the count of parts in an original vector, and so count of components in quantized representations
        valid:
          max: 255  # single byte is an index, cannot really have moar
      - id: centroid_count
        -orig-id: centroids
        type: u4
    instances:
      part_size:
        value: original_vector_size / parts_count
        doc: gives a size of each part, and so compression ratio
